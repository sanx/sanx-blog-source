---
layout: post
title: Doing HTTP PUT requests in PHP without using files
---

I think it may be that because back when the `curl` PHP extension was first created, the `HTTP PUT` method still wasn't being used by almost anyone, the `API` for doing `PUTs` using PHP curl was implemented in a very strange way.

If you want to `PUT` some data generated programmatically in a PHP script, you're supposed to do:

```php
    <?php
    $data = 'dynamically generated data that we want to PUT to a webservice endpoint...';
    // NOTE: you wouldn't hardcode the filename where you temporarily store your payload, you would
    //       use tmpfile() or tempname() to come up with a unique temporary file...
    file_put_contents('/tmp/file.txt', $data);
    
    $ch = curl_init();
    $ch = curl_setopt($ch, CURLOPT_URL, "http://example.com/endpoint.php");
    $ch = curl_setopt($ch, CURLOPT_PUT, true);
    $ch = curl_setopt($ch, CURLOPT_INFILE, fopen('/tmp/file.txt', 'r'));
    $ch = curl_setopt($ch, CURLOPT_INFILESIZE, filesize('/tmp/file.txt'));
    $ch = curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
    $curl_ret = curl_exec($ch);
    ?>
```

That's so wrong on many levels. Here I enumerate a few:

1. data is written to a file by a script only to be read back in by the same script!
2. an extra OS file `stat()` call will be made in order to get the size in bytes of the payload file.
3. you can mess things up badly if you don't use PHP's built-in `tmpfile()` or `tempname()` functions carefully to generate temporary files with unique random names.

Of course, nowadays people very much like the `HTTP PUT` method again, and there has been a resurgence in its use ever since `REST` became a trend.

Thankfully, we can make more efficient `HTTP POSTs` of data generated by our scripts with PHP curl as follows:

```php
    <?php
    $data = 'dynamically generated data that we want to PUT to a webservice endpoint...';
    
    $ch = curl_init();
    $ch = curl_setopt($ch, CURLOPT_URL, 'http://example.com/endpoint.php');
    $ch = curl_setopt($ch, CURLOPT_HTTPHEADER, array('content-type: application/json')); // you may or may not need to do this, depending on what
                                                                                         // your endpoint expects the posted content-type to be
    $ch = curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'PUT');
    $ch = curl_setopt($ch, CURLOPT_POSTFIELDS, $data); //you may have to urlencode() your data, but most likely you won't
    $ch = curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
    $curl_ret = curl_exec($ch);
    ?>
```

With this approach, we are able to do the same `HTTP PUT` without incurring in performance penalties associated with excessive use of file `stat()` operations.
